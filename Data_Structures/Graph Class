#include <iostream>
#include<vector>
#include<queue>
using namespace std;

//This class is using adjacency matrix.

class Graph{
public:
	vector<int> graph[100];
	bool* visited;
	int v,e;

Graph(int V)
{
	cout<<"This is a Undirected Graph Class "<<" with 100 edges possible "<<std::endl;
	int v,e;
	
	v=V;
	
	cout<<"Enter no of Edges ";
	cin>>e;
	
	for(int i=0;i<e;i++)
	{
		int f,s;
		cout<<"Enter Edges ";
		cin>>f>>s;
		graph[f].push_back(s);
		graph[s].push_back(f);
	}
	
	visited=new bool[v];
	
	for(int i=0;i<v;i++)
		visited[i]=false;
	
}

~Graph()
{
	delete []visited;
}

void dfs(int sv)
{
	cout<<sv<<" ";
	visited[sv]=true;
	
	for(int i=0;i<graph[sv].size();i++)
	{
		int nv=graph[sv][i];
		
		if(!visited[nv])
			dfs(nv);
	}
}

void dfs()
{
	dfs(0);
}

void bfs(int sv)
{
    queue<int> pnodes;
    pnodes.push(sv);
    visited[sv]=true;
    
    while(!pnodes.empty())
    {
        int cv=pnodes.front();
        pnodes.pop();
        cout<<cv<<" ";
        for(int i=0;i<graph[cv].size();i++)
        {
            if(!visited[graph[cv][i]])
            {
                pnodes.push(graph[cv][i]);
                visited[graph[cv][i]]=true;
            }
        }
        
    }
}

bool haspathbfs(int s,int e)
{
    bool ans=false;
    for(int i=0;graph[s].size();i++)
    {
        if(graph[s][i]==e)
            return true;
    }
    
    visited[s]=true;
    for(int i=0;graph[s].size();i++)
    {
        if(!visited[graph[s][i]])
        {
            bool temp=haspathbfs(graph[s][i],e);
            ans=ans||temp;
            
        }
        if(ans==true)
            return true;
    }
    return false;
}

void info()
   {
       cout<<"Vertices start from 0th index to n-1 index"<<endl
    <<"If no of Vertices is 5, thier no would be 0 1 2 3 4 "<<endl;
    /*
    Input:  8
            8
            0 1
            0 5
            1 2
            1 3
            2 3
            5 6
            5 7
            6 7 
    */
    
    }
};

int main()
{
    int v;
    cout<<"Enter no of Vertices"<<" ";
	cin>>v;
    Graph g(v);
  /* 
  Printing Graph via BFS and DFS
  bool * val=g.visited;
    
 for(int i=0;i<v;i++)
 {
     if(!val[i])
    {    
        g.dfs(i);
        cout<<endl;
    }
 }
 
 cout<<endl<<"BFS"<<endl;
 
 for(int i=0;i<v;i++)
    val[i]=false;
 
 for(int i=0;i<v;i++)
 {
     if(!val[i])
    {    
        g.bfs(i);
        cout<<endl;
    }
 }
 */
 bool ans=g.haspathbfs(0,4);
 cout<<"Is Edges 0 and 4 connected?"<<endl;
 cout<<((ans==true)?"Yes its connected":"No its not connected");
 
    return 0;
}
